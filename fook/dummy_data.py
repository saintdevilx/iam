# -*- coding: utf-8 -*-
dummy ={
	'names':['Deepak','Ravi','Piyush','Harshit','Manohar','Harish','Santosh','Narendra','Ankit','Vivek','Priyanka','Manju','Kalawati','Nandi','jagdish','Nishad','Sajid','Rajat','Dicky','Dilawar','Bhaskar'],
	'page_type':['artist','place','business','hotel','sportsman','model','actor'],
	'images':['1.jpg','2.jpg','3.jpg','4.jpg','5.jpg','6.jpg','7.jpg','8.jpg'],
	'long_text':[
		u"""
		Projects vs. apps

	What’s the difference between a project and an app? An app is a Web application that does something – e.g., a Weblog system, a database of public records or a simple poll app. A project is a collection of configuration and apps for a particular Web site. A project can contain multiple apps. An app can be in multiple projects.

	Your apps can live anywhere on your Python path. In this tutorial, we’ll create our poll app right next to your manage.py file so that it can be imported as its own top-level module, rather than a submodule of mysite.

	To create your app, make sure you’re in the same directory as manage.py and type this command:

	$ python manage.py startapp polls

	That’ll create a directory polls, which is laid out like this:

	polls/
	    __init__.py
	    admin.py
	    migrations/
	        __init__.py
	    models.py
	    tests.py
	    views.py

	This directory structure will house the poll application.

	The first step in writing a database Web app in Django is to define your models – essentially, your database layout, with additional metadata.

	Philosophy

	A model is the single, definitive source of data about your data. It contains the essential fields and behaviors of the data you’re storing. Django follows the DRY Principle. The goal is to define your data model in one place and automatically derive things from it.

	This includes the migrations - unlike in Ruby On Rails, for example, mi
		""",

		"""
		Migrations for 'polls':
		  0001_initial.py:
		    - Create model Question
		    - Create model Choice
		    - Add field question to choice

		By running makemigrations, you’re telling Django that you’ve made some changes to your models (in this case, you’ve made new ones) and that you’d like the changes to be stored as a migration.

		Migrations are how Django stores changes to your models (and thus your database schema) - they’re just files on disk. You can read the migration for your new model if you like; it’s the file polls/migrations/0001_initial.py. Don’t worry, you’re not expected to read them every time Django makes one, but they’re designed to be human-editable in case you want to manually tweak how Django changes things.

		There’s a command that will run the migrations for you and manage your database schema automatically - that’s called migrate, and we’ll come to it in a moment - but first, let’s see what SQL that migration would run. The sqlmigrate command takes migration names and returns their SQL:

		$ python manage.py sqlmigrate polls 0001

		You should see something similar to the following (we’ve reformatted it for readability):

		BEGIN;
		CREATE TABLE polls_question (
		    "id" serial NOT NULL PRIMARY KEY,
		    "question_text" varchar(200) NOT NULL,
		    "pub_date" timestamp with time zone NOT NULL
		);

		CREATE TABLE polls_choice (
		    "id" serial NOT NULL PRIMARY KEY,
		    "question_id" integer NOT NULL,
		    "choice_text" varchar(200) NOT NULL,
		    "votes" integer NOT NULL
		);

		CREATE INDEX polls_choice_7aa0f6ee ON "polls_choice" ("question_id");

		ALTER TABLE "polls_choice"
		  ADD CONSTRAINT polls_choice_question_id_246c99a640fbbd72_fk_polls_question_id
		    FOREIGN KEY ("question_id")
		    REFERENCES "polls_question" ("id")
		    DEFERRABLE INITIALLY DEFERRED;
		COMMIT;

		Note the following:

		    The exact output will vary depending on the database you are using. The example above is generated for PostgreSQL.
		    Table names are automatically generated by combining the name of the app (polls) and the lowercase name of the model – question and choice. (You can override this behavior.)
		    Primary keys (IDs) are added automatically. (You can override this, too.)
		    By convention, Django appends "_id" to the foreign key field name. (Yes, you can override this, as well.)
		    The foreign key relationship is made explicit by a FOREIGN KEY constraint. Don’t worry about the DEFERRABLE parts; that’s just telling PostgreSQL to not enforce the foreign key until the end of the transaction.
		    It’s tailored to the database you’re using, so database-specific field types such as auto_increment (MySQL), serial (PostgreSQL), or integer primary key autoincrement (SQLite) are handled for you automatically. Same goes for quoting of field names – e.g., using double quotes or single quotes.
		    The sqlmigrate command doesn’t actually run the migration on your database - it just prints it to the screen so that you can see what SQL Django thinks is required. It’s useful for checking what Django is going to do or if you have database administrators who require SQL scripts for changes.

		""",
		u"""If you’re applying for a software development position, you’ve got
a special set of skills to prepare. Yes, you’ll be asked to code. No,
you don’t get a computer — just a whiteboard, or sometimes just
a sheet of paper. Whiteboard and interviewing coding requires a
special set of skills. Even the best coders can get nailed on coding
questions.
A software development interview consists of about 15 min-
utes of discussion, which usually includes some questions about
your résumé and/or offers you a chance to ask the interviewer
questions. The bulk of the interview is spent on coding and algo-
rithm questions.
Coding questions can be very quick, but will often take up the
full interview time. You’re not expected to be a flawless coder. Most
questions are trick""",

"""
David and I met over drinks to discuss my job offer. This was nego-
tiation number 3. I’d thought a more social atmosphere might relax
the situation, but things didn’t quite go as planned. David ordered
just a glass of water—at a wine bar—and I couldn’t help but note
that his frugality with drinks seemed to fit so well with his lowball
offer. Of course, if you talked to him, he’d tell you that the offer was
more than generous.
We’d each appealed to higher authorities: David to the compa-
ny’s investors and to the Internet, and I to my super-CEO mother.
The venture capitalists just shrugged and told him that it was his deci-
sion. The Internet gave him a conveniently decisive range for how
much equity engineers get. My mother explained that “normal”
ranges are meaningless; that it’s a complex trade-off between salary,
equity, vesting schedule, benefits, and job expectations. “Obviously,
if your salary were a million dollars per year, you wouldn’t need any
equity.” I couldn’t disagree with her logic. Wine-is-too-expensive-
for-me David could.
""",

u"""
I used to be a big believer in the importance of luck and felt that
much of life is up to chance. What would I have been if I weren’t
born into a family that pushed education — and technology? If
I hadn’t been raised with the expectation of having a successful,
ambitious career? Or if I hadn’t been born in a country and at
a time where these opportunities are available? No doubt these
are some of the greatest strokes of luck that I— or any of us —
have had.
As we pass through grade school, then high school, then univer-
sity, and out into the job market, our luck becomes a bit more con-
trollable. Yes, the people we meet shift our goals and open us up to
new opportunities, but we are also in charge of these meetings. How
do we connect with people and build on these chance encounters?
How do we ask for help or give help to others? How do we develop
"""
	]

}